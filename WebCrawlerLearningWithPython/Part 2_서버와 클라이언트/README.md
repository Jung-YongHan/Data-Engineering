# 파이썬으로 배우는 웹 크롤러
## #크롤러를 만들만들기 위해 필요한 지식
    * 클라이언트
    * 서버
    * 웹 브라우저의 작동방식

크롤러는 웹에 대해 상당히 의존적, 수집하고자 하는 웹사이트에 따라 만드는 방식이 다름.

---
---
## 1. 클라이언트
- 데이터, 서비스를 요청하는 프로그램
- 요청한 데이터를 사용자에게 보여주는 역할
- 웹 브라우저도 하나의 클라이언트 프로그램
---
---
## 2. 서버
- 인터넷을 통해 연결된 클라이언트에 (정적인)데이터 또는 서비스를 제공하는 프로그램
- 서버가 없다면 클라이언트는 존재X
- 상당히 추상적인 개념으로 서비스를 만든 개발자만이 어떻게 만들어 졌는지 정확하게 앎  

    => 이러한 서버를 어떤 구조로 만들었는지 파악하고 유추하는 것이 굉장히 중요  
    => 서버에게 응답받는 데이터를 찾고, 그 데이터를 서버에서 어떻게 가져오는지 판단하는 과정이 중요

\*www (world wide web) - 초기에 문서 공유를 위해 만들어진 것

<br>

### 2-1. 서버의 종류
1. 영상 -   
영상 서버의 경우 다른 서버와 다르게 데이터를 한 번에 주는 것이 아니라 일정량 분할하여 전송, 이것을 **스트리밍**이라고 함  
영상을 한 번에 받는다면 부담되기 때문에 스트리밍 방식을 많이 사용

2. 파일 -  
과거 파일을 제공하는 서비스 중 대표적인 것 - P2P  
오늘 날에는 토렌트, 각종 드라이브를 사용. 이러한 것도 서버의 한 종류  
FTP, SFTP를 이용하여 개인이 파일 서버를 구축하기도 함

3. 채팅 및 음성 -  
메신저 - 채팅을 제공하는 프로그램. 메신저 프로그램도 서버가 없으면 절대 동작할 수 없음.

4. 도메인 -  
인터넷을 통해 www.domain.com과 같은 형태로 인터넷 사용.  
이러한 문자로 된 것은 IP라고 하는 주소로 대응되어 있음.  
도메인 주소에 대해 대응되는 IP를 알려주는 것을 DNS(Domain Name Survice)

5. 게임 -  
게임 서버를 통해 인터넷을 연결하여 마치 한 공간에 있는 것처럼 표현.  
채팅 서버와 구조가 비슷함. 채팅은 대화 내용을 전달하게 되고 게임 서버는 서로의 위치 정보를 주고 받음

6. 웹 -  
웹 브라우저를 통해 요청된 페이지를 받아오는 서버  
서버는 웹을 정적 페이지, 동적 페이지와 같은 형태로 제공 

\***정리**  
서버는 특정 데이터만 제공하는 것이 아니라 상황에 맞춰 다양한 데이터를 제공

---
---
## 3. 서버와 클라이언트가 데이터를 주고받는 방법
\*프로토콜 - 서버와 클라이언트의 데이터를 주고받는 규약

<br>

### 3-1. 요청 메소드
CRUD - Create, Read, Update, Delete 클라이언트가 서버에 데이터를 요청할 때 쓰는 네 가지 타입 

실제로 클라이언트는 CRUD로 직접 명시하지 않고 요청 헤더에  
GET, POST, PUT, DELETE의 형태로 메소드를 정의. 아래과 같이 매핑  
- GET : Read  
클라이언트가 서버에 데이터를 요청할 때 사용하는 메소드. 서버의 종류에 따라 다양한 데이터를 요청

- POST : Create  
특정 데이터를 추가하는 요청. 데이터를 만들어 내는 것. 즉, DB에 데이터를 추가한다는 의미

- PUT : Update  
특정 데이터에 대해 수정하라는 요청. DB에 존재하는 데이터를 수정.

- DELETE : Delete  
특정 데이터를 삭제하라는 의미. DB에 존재하는 데이터를 삭제.

\***정리**   
데이터를 요청할 때 데이터를 요청하는 형태에 따라 메소드를 달리 함.  
데이터를 요청할 때 GET 요청만 할 필요 없으며, POST, PUT, DELETE로 해도 큰 상관은 없음  

실제 사이트에선 GET과 POST를 이용하여 데이터를 요청.  
이 외에도 상당히 많은 메소드가 존재하지만 거의 사용하지 않고, 이 중에서도 GET과 POST 요청을 주로 사용  

크롤러는 데이터를 가져오는 것이 관심 사항이기 때문에 데이터를 수정하고 삭제하는 PUT, DELETE 메소드는 신경 쓰지 않음

---

### 3-2. 응답 코드
서버가 클라이언트 요청을 처리하고 난 후 상태에 따라 반환하는 코드

1. 1xx 조건부 응답 -  
클라이언트가 데이터를 일부만 포함해 보내어 서버가 데이터를 더 보내라고 하는 응답 코드.  
100, 101, 102를 제공하지만 1xx는 사용하지 않아야 함.

2. 2xx 성공 -  
서버가 클라이언트로부터의 요청을 성공적으로 처리한 후 반환하는 응답 코드.  

    - 200 - 서버가 클라이언트의 요청을 성공적으로 처리. 웹 페이지에서는 페이지 요청이 정상적으로 완료되면 200 코드 반환.  

    - 201 - 서버가 요청된 클라이언트의 정보를 정상적으로 저장. POST 요청으로 데이터 저장 요청 시 잘 저장됐다면 201 코드 반환.

    - 202 - 요청 접수만 되고 아직 처리되지 않은 상태. 서버는 현재의 상태를 보여주는 페이지를 제공해 주어야 함.

    - 203 - 정보를 신뢰할 수 없는 경우.

    - 204 - 클라이언트로 반환되는 데이터가 없을 때. 즉, 빈 콘텐츠 제공

    - 205 - 서버는 요청을 성공적으로 처리. 반환되는 콘텐츠가 비어있을 경우 클라이언트로부터 재설정시키는 코드

    - 206 - 일부 콘텐츠

    - 207 - 다중 상태

    - 208 - 이미 보고됨  

    많이 사용되는 응답 코드는 200, 201, 204번

3. 3xx 새로고침 완료  
클라이언트가 요청을 완료하기 위해서 작업이 남아있는 코드. 보통 새로고침을 한 경우 반환하는 응답 코드.

    - 300 - 여러 선택 항목
    - 301 - 영구 이동
    - 302 - 임시 이동
    - 303 - 기타 위치 보기
    - 304 - 수정되지 않음
    - 305 - 프록시 사용
    - 307 - 임시 새로고침
    - 308 - 영구 새로고침

    많이 사용되는 응답 코드는 301, 302, 303, 304, 307

4. 4xx 요청 오류(매우 많아서 중요한 코드만 기록)  
클라리언트의 요청이 잘못됐을 때 반환하는 응답 코드. 즉, 문제 발생 원인이 클라이언트에게 있음.

    - 400 - 잘못 요청
    - 401 - 권한 없음. 예로 로그인 페이지가 필요한 페이지를 로그인 없이 접속하려는 경우 반환되는 코드
    - 403 - 금지됨. 예로 로그인된 사용자 관리자 페이지로 접속하려고 시도하는데 관리자가 아닌 경우 반환되는 코드
    - 404 - 찾을 수 없음. 흔히 보이는 코드로 존재하지 않는 URL을 요청하여 페이지를 접속할 수 없을 때 반환하는 응답 코드.
    - 405 - 잘못된 요청 메소드 사용

5. 5xx 서버 오류(많아서 중요한 코드만 기록)  
서버의 설정, 코드 등의 문제로 오류가 났을 때 반환되는 코드

    - 500 - 내부 서버 오류. 보통 서버 코드의 문제 시 반환되는 응답 코드
    - 502 - 불량 게이트웨이(웹 서버를 게이트웨이라고 부르기도 함)
    - 503 - 서비스를 사용할 수 없음
    - 504 - 게이트웨이 시간 초과
    - 505 - http 버전이 지원되지 않음. 이 경우 https 사용

---
### 3-3. 헤더
서버와 클라이언트 간 데이터를 주고 받을 때, 헤더라는 정보를 포함하여 보낸다.  
이때 헤더는 서버와 클라이언트의 정보를 포함하고 있는 것.  

- Request Header - 클라이언트가 서버에 데이터를 요청할 때 포함된 헤더  

    문서와 구성 형태 및 형식을 포함(클라이언트의 주요 헤더가 됨.)  
    - Accept - 클라이언트의 사용 가능 미디어 타입 
    - Accept-Charset - 클라이언트에서 사용할 수 있는 문자 집합
    - Accept-Encoding - 클라이언트에서 제공되는 인코딩 방법(압축)
    - Accept-Language - 클라이언트가 인식할 수 있는 언어
    - Host - 서버의 기본 URL
    - If-Match - ETag값 비교 후 메소드 수행
    - If-None-Match- ETag값 비교 후 다를 때 -> method 수행
    - If-Unmodified-Since - 헤더값이 지정된 날짜로부터 수정이 없는 경우 메소드 수행
    - Max-Forwards - 이 메시지가 거쳐갈 수 있는 최대 Proxy의 개수 지정
    - Proxy-Authorization - 비공개 프록시 서버 유저 인증을 위한 코드
    - Range - 자원의 일부분만 받을 때(이어받기 기능) 받을 범위 지정
    - From - 메일 주소
    - Cookie - 쿠키 정보
    - refered - 클라이언트가 서버에 요청하기 직전에 머물렀던 주소(서버에서 해당 값을 검사하는 경우가 있기 때문에 크롤러에서 이 부분을 만들어 줘야 하는 경우가 있음.)
    - User-Agent - 브라우저 정보(클라이언트 프로그램 : 크롬, 사파리 등)
    - Method - 요청 메소드
    - HTTP-Version - http 버전
    - Request-URI - 요청 데이터의 절대 주소, 상대 주소
    - Authorization - 사용자 인증 정보

- Response Header - 서버가 클라이언트에게 응답할 때 포함된 헤더  

    서버가 클라이언트에 응답할 때 요청과 서버의 구성을 포함한 헤더  
    - HTTP-Version - http 버전
    - Status-code - 응답 코드
    - Respon-Phrase - 응답 코드에 대한 간략한 설명
    - Location - 요구한 정보 실제 위치. 옮겨지거나 다를 경우 정보 주소가 실제 위치 정보
    - Serve - 서버 프로그램의 이름과 버전 정보
    - WWW-Authenticate - 사용자 인증이 필요한 자원 요구 시 데이터와 서버가 제공하는 인증 방식
    - Age - 요구 후 Original Server에서 응답을 생성하기까지의 시간
    - Proxy-Authenticate - 프록시 서버일 경우 유저 인증을 요구하기 위한 헤더
    - Public - 서버에서 지원 가능한 메소드 리스트
    - Retry-After : 503 에러 시 해당 시간만큼 기다리라는 의미
    - Warning - 상태 코드와 응답 구문에 추가적인 경고
    - Set-Cookie - 서버측에서 세션 쿠키 정보 설정
    - Expires - 캐시 유효 기간
    - Last-Modified - 리소스 마지막 수정날

- General Header - 서버와 클라이언트 양측 모두에게 사용되는 일반적인 정보가 포함된 헤더  

    서버와 클라이언트에서 일반적인 정보를 포함하는 헤더
    - Date - 현재 시간
    - Pragma - 캐시 제어(http1.1에서는 사용 안 함)
    - Cache-Control - 캐시 유무, 업데이트 시간, 내용, 지움 등의 정보(캐시 정보)
    - Connection - 연결 지속
    - Transfer-Encoding - [entity-body]의 압축 방식
    - Upgrade - 프로토콜 변경 시
    - Via - 중계 서버(프록시, 게이트웨이 등)

- Entity Header - 메시지에 대한 설명을 포함하는 헤더

    메시지에 대한 설명을 포함하는 헤더
    - Content-Encoding - [entity-body]의 리소스 압축 방식(gzip, compress, deflate 등)
    - Content-Length - [entity-body]의 리소스 크기(단위: Byte)
    - Content-Type - [entity-body]의 미디어 타입

\***정리**   
모든 헤더 정보를 포함할 필요는 없으며, 서버와 클라이언트는 상황에 따라 필요한 정보만 포함하여 헤더를 만듦.

---
---

## 4. URL
데이터를 보내기 위해서 URL의 구조를 알아야 하며, URL 구조를 얼마나 잘 파악하느냐에 따라 효율적인 크롤러를 만들 수 있음.  

\*URL - Uniform Resource Locator, 네트워크 상에서 자원을 요청하는 규약.  
웹 브라우저, 스마트폰 애플리케이션, 컴퓨터 응용 프로그램들은 서버와 데이터를 주고 받을 때 URL을 이용하여 데이터를 주고 받음.

*URL 구조 - ' 프로토콜://주소 또는 IP:포트 번호/리소스 경로?쿼리스트링 '  

- 인터넷에서 주로 사용하는 프로토콜은 http. 이외에 FTP, SFTP, SSH 등 다양한 프로토콜 존재.
- IP 주소는 우리가 데이터를 요청하는 타겟.
- 프로토콜, IP 주소, 포트 번호는 우리가 요청하고자 하는 타켓을 의미.
- 프로토콜과 포트 번호는 미리 정해진 규약이 존재. http의 경우 80번 포트, https는 443번 포트 사용.
- 이 외 파일 전소에 사용하는 FTP는 20번, 21번 사용
- 원격 컴퓨터에 접속하는 프로토콜 telnet은 23번, ssh는 22번 사용
- http://사이트를 입력하면 http가 80번 포트 번호를 의미하기 때문에 사이트의 80번 포트 번호로 열린 서버에 데이터를 요청
- IP는 목적지 컴퓨터가 되며 포트 번호는 목적지 컴퓨터에서 어떤 프로그램을 의미하는지 알려주게 됨.
- http는 웹을 제공해주는 서비스, ftp는 파일을 주고받는 서비스 등 다양한 서비스를 이용할 수 있음.
- IP 주소와 프로토콜, 포트 번호를 이용하여 타켓에 접속하면 데이터를 요청해야 함.
- http와 https는 리소스 경로, 쿼리스트링과 헤더를 통하여 요청하고자 하는 데이터를 포함할 수 있음.  

4.1.1 리소스 경로  

주소 다음 슬래시(/)로 시작하는 부분. 클라이언트가 요청하는 리소스의 경로가 포함. 이 부분에 데이터를 함께 보낼 수 있음.  

ex)  ( _: 링크 지정 X를 위함 )  
A 제품 페이지 : _http://www.example.com/product/1  
B 제품 페이지 : _http://www.example.com/product/2  
C 제품 페이지 : _http://www.example.com/product/3  
example사이트에서 3개의 제품 페이지에 들어갔을 때 위와 같이 URL이 변한다면 해당 페이지는 리소스 경로에 데이터를 함께 보내는 것  
이 경우 1, 2, 3이 데이터에 해당

4.1.2 쿼리스트링  

클라이언트가 서버에 보내는 데이터. 리소스 경로 이후에 오며 물음표(?)로 구분

ex)   
A 제품 페이지 : _http://www.example.com/product?pro=1&cate=2  
B 제품 페이지 : _http://www.example.com/product?pro=2&cate=2  
C 제품 페이지 : _http://www.example.com/product?pro=3&cate=2  
? 뒤에는 변수=데이터&변수=데이터&변수=데이터의 형태로 엔드(&)를 이용하여 각각의 데이터를 구분하여 전송

4.1.3 header body  

헤더의 body라는 곳에 데이터를 포함하여 보낼 수 있음.  
POST 요청을 하게 되면 데이터를 body에 실어 보내게 됨.  
앞의 두 방식인 리소스경로, 쿼리스트링에 데이터를 함께 보내면 데이터를 보내는데 한계가 있음. (더 많은 데이터를 보내기 위함)  
이 경우 URL로 확인 불가능  

웹 페이지에서 마우스 오른쪽 버튼을 클릭, 검사를 누르면 개발자 도구가 나옴.(윈도우 F12, Mac Command+l)  

Request Method가 POST일 때만 Body에 데이터가 존재.  
Body Data의 경우 네트워크 탭에서 Form Data라고 표현. 쿼리스트링의 경우 Query String Parameters라고 표현  

웹 페이지 접속, 새로고침과 같은 일반적인 접속 방식은 GET 요청이라 Body에 데이터가 비어 있음.  
POST는 데이터를 Body에 포함해 전송하기 때문에 요청 메소드가 POST라면 반드시 Body 데이터를 확인해야 함.